# 標準入力で1行の文字列が与えられるので、それを入力して、そのまま1行で出力してください。

# 入力される値
# 文字列Sが1行で入力されます。

# 期待する出力
# 1行での出力

# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・Sは1文字以上100文字以下の文字列
# ・Sの各文字は英小文字または大文字または数字または半角スペース

# 入力例1
# abc

# 出力例1
# abc

# 入力例2
# a b c

# 出力例2
# a b c

# 入力例3
# 2000

# 出力例3
# 2000

# 入力例4
# 0x04a12bE

# 出力例4
# 0x04a12bE

  # 標準入力から1行受け取る
s = gets.chomp

# 文字列の検証
# 文字列の長さが1文字以上100文字以下かつ、
# 英小文字、大文字、数字、半角スペースのみで構成されていることを確認する
if s.length.between?(1, 100) && s =~ /\A[a-zA-Z0-9 ]*\z/
  # 条件を満たしている場合は文字列を出力する
  puts s
else
  # 条件を満たしていない場合はエラーメッセージを出力する（または他の処理を行う）
  puts "入力された文字列が条件に合致しません。"
end


# s =~

# この部分は、文字列 s が後ろに続く正規表現とマッチするかどうかをチェックする演算子です。
# この演算子は、文字列が正規表現に一致した場合にはマッチした位置（0以上の数値）を返し、一致しない場合は nil を返します。
# /\A[a-zA-Z0-9 ]*\z/

# /.../ は正規表現リテラルの開始と終了を示します。
# \A は文字列の先頭を意味します。文字列の始まりを表すアンカーです。
# [a-zA-Z0-9 ] は文字クラスです。この中の任意の1文字に一致します。
# a-z はすべての英小文字に一致します。
# A-Z はすべての英大文字に一致します。
# 0-9 はすべての数字に一致します。
# （スペース）は半角スペースに一致します。
# * は直前の文字（この場合は文字クラス [a-zA-Z0-9 ]）が0回以上繰り返されることに一致します。つまり、文字クラスに含まれる任意の文字が0文字以上連続していてもマッチすることを意味します。
# \z は文字列の末尾を意味します。文字列の終わりを表すアンカーです。
# つまり、この正規表現は文字列が先頭（\A）から末尾（\z）まで英小文字、英大文字、数字、半角スペースのいずれかだけで構成されているかをチェックします。そして、* によって文字列が空（0文字）であっても、または複数の文字で構成されていても構いません。

# 総合すると、この正規表現を使った式は、与えられた文字列 s がこれらの条件を満たしているかどうかを検証するために使用されます。
